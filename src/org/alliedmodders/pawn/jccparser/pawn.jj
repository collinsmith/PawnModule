options {
    ERROR_REPORTING = true;
    STATIC = false;
    TOKEN_FACTORY = "Token";
    JDK_VERSION = "1.8";
    BUILD_PARSER = true;
}

PARSER_BEGIN(PawnParser)

package org.alliedmodders.pawn.jccparser;

import java.io.*;
import java.util.*;

public class PawnParser {
    private static final String PARSER_VERSION_STR = "0.0.1";

    public static void main(String[] args) {
	System.out.printf("Pawn Parser %s%n", PARSER_VERSION_STR);
	PawnParser parser;
	switch (args.length) {
	    case 0:
		System.out.println("Reading from standard input . . .");
		parser = new PawnParser(System.in);
		break;
	    case 1:
		System.out.printf("Reading from file '%s' . . .%n", args[0]);
		try {
		    parser = new PawnParser(new FileInputStream(args[0]));
		} catch (FileNotFoundException e) {
		    System.out.printf("File '%s' not found%n", args[0]);
		    return;
		}
		
		break;
	    default:
		System.out.println("Usage:");
		System.out.println("\tjava PawnParser < inputFile");
		System.out.println("\tjava PawnParser inputFile");
		System.out.println("Exiting parser . . .");
		return;
	}

	try {
	    parser.CompilationUnit();
	    System.out.println("Pawn program parsed successfully.");
	} catch (ParseException e) {
	    System.out.println("Encoutered errors during parse.");
	    e.printStackTrace();
	}
    }
}

PARSER_END(PawnParser)

/*****************************************
 * THE PAWN LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

void CompilationUnit() : {} {
    (	PreprocessorDirective()
    |	Declaration()
    )*
    <EOF>
}

void Declaration() : {} {
    LOOKAHEAD(PrototypeDeclaration()) PrototypeDeclaration()
|   LOOKAHEAD(FunctionDeclaration()) FunctionDeclaration()
|   VariableDeclaration()
|   EnumDeclaration()
}

void PreprocessorDirective() : {} {
    <PREPROCESSOR>
}

void PrototypeDeclaration() : {} {
    [PrototypeClassSpecifier()] Identifier() FormalParameters() EOS()
}

void VariableDeclaration() : {} {
    VariableClassSpecifier() [ StorageSpecifier() ] IdentifierDeclarationList() EOS()
}

void FunctionDeclaration() : {} {
    [PrototypeClassSpecifier()] Identifier() FormalParameters() <LBRACE> <RBRACE>
}

void PrototypeClassSpecifier() : {} {
    <PUBLIC>
|   <STATIC>
|   <STOCK>
|   <NATIVE>
|   <FORWARD>
}

void Identifier() : {} {
    [Tag()] <IDENTIFIER>
}

void Tag() : {} {
    <TAG>
}

void FormalParameters() : {} {
    <LPAREN>
    (	LOOKAHEAD(FormalParameterEllipsis()) FormalParameterEllipsis()
    |	[   FormalParameter()
	(   LOOKAHEAD( <COMMA> FormalParameter() <COMMA> )
	    <COMMA> FormalParameter() )*
	[   <COMMA> FormalParameterEllipsis() ]
	]
    )
    <RPAREN>
}

void FormalParameterEllipsis() : {} {
    [Tag()] <ELLIPSIS>
}

void FormalParameter() : {} {
    [StorageSpecifier()]
    (	ByRefVariableDeclarator()
    |	VariableDeclarator()
    )
}

void StorageSpecifier() : {} {
    <CONST>
}

void ByRefVariableDeclarator() : {} {
    ByRef() Identifier() [ <ASSIGN> NumericLiteral() ]
}

void ByRef() : {} {
    <BIT_AND>
}

void NumericLiteral() : {} {
    IntegerLiteral()
|   RationalLiteral()
|   BooleanLiteral()
}

void IntegerLiteral() : {} {
    <POSITIVE_INTEGER_LITERAL>
|   <NEGATIVE_INTEGER_LITERAL>
}

void RationalLiteral() : {} {
    <RATIONAL_LITERAL>
}

void BooleanLiteral() : {} {
    <TRUE>
|   <FALSE>
}

void VariableDeclarator() : {} {
    VariableDeclaratorIdentifier() [ <ASSIGN> Initializer() ]
}

void VariableDeclaratorIdentifier() : {} {
    Identifier() ( <LBRACKET> [ ConstantExpression() ] <RBRACKET> )*
}

void ConstantExpression() : {} {
    <POSITIVE_INTEGER_LITERAL>
|   Identifier()
}

void Initializer() : {} {
    LOOKAHEAD(<LBRACE> <RBRACE>) <LBRACE> <RBRACE>
|   <LBRACE> InitializerList() [<COMMA>] <RBRACE>
|   Literal()
}

void InitializerList() : {} {
    Initializer()
    (	LOOKAHEAD(<COMMA> (<LBRACE>|Literal()))
	<COMMA> Initializer()
    )*
}

void Literal() : {} {
    NumericLiteral()
|   CharacterLiteral()
|   StringLiteral()
}

void CharacterLiteral() : {} {
    <CHARACTER_LITERAL>
}

void StringLiteral() : {} {
    <STRING_LITERAL>
}

void EOS() : {} {
    <SEMICOLON>
}

void VariableClassSpecifier() : {} {
    <NEW>
|   <PUBLIC>
|   <STATIC>
|   <STOCK>
}

void IdentifierDeclarationList() : {} {
    IdentifierDeclaration() ( <COMMA> IdentifierDeclaration() )*
}

void IdentifierDeclaration() : {} {
    VariableDeclarator()
}

void EnumDeclaration() : {} {
    <ENUM>
}